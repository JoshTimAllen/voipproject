import "./chunk-X7HCJ7ZS.js";
import "./chunk-EMTS6HMJ.js";
import {
  writable
} from "./chunk-KCM2OMET.js";
import {
  SvelteComponentDev,
  add_location,
  assign,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-KS2GGZ7Y.js";
import "./chunk-ZUGQ3PSC.js";
import "./chunk-NEAGQJHQ.js";

// node_modules/yrv/build/dist/vendor.js
var rr = Object.create;
var E = Object.defineProperty;
var er = Object.getOwnPropertyDescriptor;
var tr = Object.getOwnPropertyNames;
var nr = Object.getPrototypeOf;
var ar = Object.prototype.hasOwnProperty;
var F = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var cr = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let a of tr(e))
      !ar.call(r, a) && a !== t && E(r, a, { get: () => e[a], enumerable: !(n = er(e, a)) || n.enumerable });
  return r;
};
var ir = (r, e, t) => (t = r != null ? rr(nr(r)) : {}, cr(e || !r || !r.__esModule ? E(t, "default", { value: r, enumerable: true }) : t, r));
var k = F((vr, A) => {
  "use strict";
  A.exports = (r) => encodeURIComponent(r).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`);
});
var U = F((br, R) => {
  "use strict";
  var $ = "%[a-f0-9]{2}", C = new RegExp($, "gi"), N = new RegExp("(" + $ + ")+", "gi");
  function x(r, e) {
    try {
      return decodeURIComponent(r.join(""));
    } catch {
    }
    if (r.length === 1)
      return r;
    e = e || 1;
    var t = r.slice(0, e), n = r.slice(e);
    return Array.prototype.concat.call([], x(t), x(n));
  }
  function sr(r) {
    try {
      return decodeURIComponent(r);
    } catch {
      for (var e = r.match(C), t = 1; t < e.length; t++)
        r = x(e, t).join(""), e = r.match(C);
      return r;
    }
  }
  function fr(r) {
    for (var e = { "%FE%FF": "��", "%FF%FE": "��" }, t = N.exec(r); t; ) {
      try {
        e[t[0]] = decodeURIComponent(t[0]);
      } catch {
        var n = sr(t[0]);
        n !== t[0] && (e[t[0]] = n);
      }
      t = N.exec(r);
    }
    e["%C2"] = "�";
    for (var a = Object.keys(e), i = 0; i < a.length; i++) {
      var c = a[i];
      r = r.replace(new RegExp(c, "g"), e[c]);
    }
    return r;
  }
  R.exports = function(r) {
    if (typeof r != "string")
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof r + "`");
    try {
      return r = r.replace(/\+/g, " "), decodeURIComponent(r);
    } catch {
      return fr(r);
    }
  };
});
var T = F((jr, q) => {
  "use strict";
  q.exports = (r, e) => {
    if (!(typeof r == "string" && typeof e == "string"))
      throw new TypeError("Expected the arguments to be of type `string`");
    if (e === "")
      return [r];
    let t = r.indexOf(e);
    return t === -1 ? [r] : [r.slice(0, t), r.slice(t + e.length)];
  };
});
var I = F((Sr, D) => {
  "use strict";
  D.exports = function(r, e) {
    for (var t = {}, n = Object.keys(r), a = Array.isArray(e), i = 0; i < n.length; i++) {
      var c = n[i], s = r[c];
      (a ? e.indexOf(c) !== -1 : e(c, s, r)) && (t[c] = s);
    }
    return t;
  };
});
var Q = F((o) => {
  "use strict";
  var ur = k(), lr = U(), B = T(), or = I(), dr = (r) => r == null;
  function hr(r) {
    switch (r.arrayFormat) {
      case "index":
        return (e) => (t, n) => {
          let a = t.length;
          return n === void 0 || r.skipNull && n === null || r.skipEmptyString && n === "" ? t : n === null ? [...t, [l(e, r), "[", a, "]"].join("")] : [...t, [l(e, r), "[", l(a, r), "]=", l(n, r)].join("")];
        };
      case "bracket":
        return (e) => (t, n) => n === void 0 || r.skipNull && n === null || r.skipEmptyString && n === "" ? t : n === null ? [...t, [l(e, r), "[]"].join("")] : [...t, [l(e, r), "[]=", l(n, r)].join("")];
      case "comma":
      case "separator":
        return (e) => (t, n) => n == null || n.length === 0 ? t : t.length === 0 ? [[l(e, r), "=", l(n, r)].join("")] : [[t, l(n, r)].join(r.arrayFormatSeparator)];
      default:
        return (e) => (t, n) => n === void 0 || r.skipNull && n === null || r.skipEmptyString && n === "" ? t : n === null ? [...t, l(e, r)] : [...t, [l(e, r), "=", l(n, r)].join("")];
    }
  }
  function gr(r) {
    let e;
    switch (r.arrayFormat) {
      case "index":
        return (t, n, a) => {
          if (e = /\[(\d*)\]$/.exec(t), t = t.replace(/\[\d*\]$/, ""), !e) {
            a[t] = n;
            return;
          }
          a[t] === void 0 && (a[t] = {}), a[t][e[1]] = n;
        };
      case "bracket":
        return (t, n, a) => {
          if (e = /(\[\])$/.exec(t), t = t.replace(/\[\]$/, ""), !e) {
            a[t] = n;
            return;
          }
          if (a[t] === void 0) {
            a[t] = [n];
            return;
          }
          a[t] = [].concat(a[t], n);
        };
      case "comma":
      case "separator":
        return (t, n, a) => {
          let i = typeof n == "string" && n.includes(r.arrayFormatSeparator), c = typeof n == "string" && !i && g(n, r).includes(r.arrayFormatSeparator);
          n = c ? g(n, r) : n;
          let s = i || c ? n.split(r.arrayFormatSeparator).map((f) => g(f, r)) : n === null ? n : g(n, r);
          a[t] = s;
        };
      default:
        return (t, n, a) => {
          if (a[t] === void 0) {
            a[t] = n;
            return;
          }
          a[t] = [].concat(a[t], n);
        };
    }
  }
  function L(r) {
    if (typeof r != "string" || r.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function l(r, e) {
    return e.encode ? e.strict ? ur(r) : encodeURIComponent(r) : r;
  }
  function g(r, e) {
    return e.decode ? lr(r) : r;
  }
  function H(r) {
    return Array.isArray(r) ? r.sort() : typeof r == "object" ? H(Object.keys(r)).sort((e, t) => Number(e) - Number(t)).map((e) => r[e]) : r;
  }
  function J(r) {
    let e = r.indexOf("#");
    return e !== -1 && (r = r.slice(0, e)), r;
  }
  function yr(r) {
    let e = "", t = r.indexOf("#");
    return t !== -1 && (e = r.slice(t)), e;
  }
  function P(r) {
    r = J(r);
    let e = r.indexOf("?");
    return e === -1 ? "" : r.slice(e + 1);
  }
  function M(r, e) {
    return e.parseNumbers && !Number.isNaN(Number(r)) && typeof r == "string" && r.trim() !== "" ? r = Number(r) : e.parseBooleans && r !== null && (r.toLowerCase() === "true" || r.toLowerCase() === "false") && (r = r.toLowerCase() === "true"), r;
  }
  function V(r, e) {
    e = Object.assign({ decode: true, sort: true, arrayFormat: "none", arrayFormatSeparator: ",", parseNumbers: false, parseBooleans: false }, e), L(e.arrayFormatSeparator);
    let t = gr(e), n = /* @__PURE__ */ Object.create(null);
    if (typeof r != "string" || (r = r.trim().replace(/^[?#&]/, ""), !r))
      return n;
    for (let a of r.split("&")) {
      if (a === "")
        continue;
      let [i, c] = B(e.decode ? a.replace(/\+/g, " ") : a, "=");
      c = c === void 0 ? null : ["comma", "separator"].includes(e.arrayFormat) ? c : g(c, e), t(g(i, e), c, n);
    }
    for (let a of Object.keys(n)) {
      let i = n[a];
      if (typeof i == "object" && i !== null)
        for (let c of Object.keys(i))
          i[c] = M(i[c], e);
      else
        n[a] = M(i, e);
    }
    return e.sort === false ? n : (e.sort === true ? Object.keys(n).sort() : Object.keys(n).sort(e.sort)).reduce((a, i) => {
      let c = n[i];
      return Boolean(c) && typeof c == "object" && !Array.isArray(c) ? a[i] = H(c) : a[i] = c, a;
    }, /* @__PURE__ */ Object.create(null));
  }
  o.extract = P;
  o.parse = V;
  o.stringify = (r, e) => {
    if (!r)
      return "";
    e = Object.assign({ encode: true, strict: true, arrayFormat: "none", arrayFormatSeparator: "," }, e), L(e.arrayFormatSeparator);
    let t = (c) => e.skipNull && dr(r[c]) || e.skipEmptyString && r[c] === "", n = hr(e), a = {};
    for (let c of Object.keys(r))
      t(c) || (a[c] = r[c]);
    let i = Object.keys(a);
    return e.sort !== false && i.sort(e.sort), i.map((c) => {
      let s = r[c];
      return s === void 0 ? "" : s === null ? l(c, e) : Array.isArray(s) ? s.reduce(n(c), []).join("&") : l(c, e) + "=" + l(s, e);
    }).filter((c) => c.length > 0).join("&");
  };
  o.parseUrl = (r, e) => {
    e = Object.assign({ decode: true }, e);
    let [t, n] = B(r, "#");
    return Object.assign({ url: t.split("?")[0] || "", query: V(P(r), e) }, e && e.parseFragmentIdentifier && n ? { fragmentIdentifier: g(n, e) } : {});
  };
  o.stringifyUrl = (r, e) => {
    e = Object.assign({ encode: true, strict: true }, e);
    let t = J(r.url).split("?")[0] || "", n = o.extract(r.url), a = o.parse(n, { sort: false }), i = Object.assign(a, r.query), c = o.stringify(i, e);
    c && (c = `?${c}`);
    let s = yr(r.url);
    return r.fragmentIdentifier && (s = `#${l(r.fragmentIdentifier, e)}`), `${t}${c}${s}`;
  };
  o.pick = (r, e, t) => {
    t = Object.assign({ parseFragmentIdentifier: true }, t);
    let { url: n, query: a, fragmentIdentifier: i } = o.parseUrl(r, t);
    return o.stringifyUrl({ url: n, query: or(a, e), fragmentIdentifier: i }, t);
  };
  o.exclude = (r, e, t) => {
    let n = Array.isArray(e) ? (a) => !e.includes(a) : (a, i) => !e(a, i);
    return o.pick(r, n, t);
  };
});
var X = ir(Q());
var w = function(r) {
  function e(t, n) {
    var a = "Unreachable '" + (t !== "/" ? t.replace(/\/$/, "") : t) + "', segment '" + n + "' is not defined";
    r.call(this, a), this.message = a, this.route = t, this.path = n;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e;
}(Error);
function G(r, e) {
  var t, n, a = -100, i = [];
  t = r.replace(/[-$.]/g, "\\$&").replace(/\(/g, "(?:").replace(/\)/g, ")?").replace(/([:*]\w+)(?:<([^<>]+?)>)?/g, function(f, d, u) {
    return i.push(d.substr(1)), d.charAt() === ":" ? (a += 100, "((?!#)" + (u || "[^#/]+?") + ")") : (n = true, a += 500, "((?!#)" + (u || "[^#]+?") + ")");
  });
  try {
    t = new RegExp("^" + t + "$");
  } catch {
    throw new TypeError("Invalid route expression, given '" + e + "'");
  }
  var c = r.includes("#") ? 0.5 : 1, s = r.length * a * c;
  return { keys: i, regex: t, _depth: s, _isSplat: n };
}
var m = function(e, t) {
  var n = G(e, t), a = n.keys, i = n.regex, c = n._depth, s = n._isSplat;
  function f(d) {
    var u = d.match(i);
    if (u)
      return a.reduce(function(y, O, j) {
        return y[O] = typeof u[j + 1] == "string" ? decodeURIComponent(u[j + 1]) : null, y;
      }, {});
  }
  return f.regex = i, f.keys = a, { _isSplat: s, _depth: c, match: f };
};
m.push = function(e, t, n, a) {
  var i = t[e] || (t[e] = {});
  return i.pattern || (i.pattern = new m(e, a), i.route = (n || "").replace(/\/$/, "") || "/"), t.keys = t.keys || [], t.keys.includes(e) || (t.keys.push(e), m.sort(t)), i;
};
m.sort = function(e) {
  e.keys.sort(function(t, n) {
    return e[t].pattern._depth - e[n].pattern._depth;
  });
};
function K(r, e) {
  return "" + (e && e !== "/" ? e : "") + (r || "");
}
function b(r, e) {
  var t = r.match(/<[^<>]*\/[^<>]*>/);
  if (t)
    throw new TypeError("RegExp cannot contain slashes, given '" + t + "'");
  var n = r.split(/(?=\/|#)/), a = [];
  n[0] !== "/" && n.unshift("/"), n.some(function(i, c) {
    var s = a.slice(1).concat(i).join("") || null, f = n.slice(c + 1).join("") || null, d = e(i, s, f ? "" + (i !== "/" ? i : "") + f : null);
    return a.push(i), d;
  });
}
function mr(r, e) {
  var t = e.refs, n = {}, a = [], i;
  return b(r, function(c, s, f) {
    if (!e.keys)
      throw new w(r, c);
    var d;
    if (e.keys.some(function(u) {
      var y = e[u].pattern, O = y.match, j = y._length, p = y._isSplat, _ = O(p && f || c);
      if (_) {
        var Y = (t[e[u].route] || []).concat(t[e[u].route + "/"] || []).concat(t[e[u].route + "#"] || []);
        return Object.assign(n, _), Y.forEach(function(v) {
          if (!a.some(function(Z) {
            return Z.key === v;
          })) {
            var h = Object.assign({}, t[v]), S = false;
            h.exact ? S = f === null : S = !(c && s === null) || c === s || p || !f, h.matches = S, h.params = Object.assign({}, n), h.route = h.fullpath, h.depth += O.keys.length, h.path = p && f || s || c, delete h.fullpath, a.push(h);
          }
        }), f === null && !e[u].keys ? true : !p && !f && e.keys.some(function(v) {
          return v.includes("*");
        }) ? false : (i = p, e = e[u], d = true, true);
      }
      return false;
    }), !(d || e.keys.some(function(u) {
      return e[u].pattern.match(c);
    })))
      throw new w(r, c);
    return i || !d;
  }), a.sort(function(c, s) {
    return s.fallback && !c.fallback ? -1 : c.fallback && !s.fallback ? 1 : s.route.includes("#") && !c.route.includes("#") ? -1 : c.route.includes("#") && !s.route.includes("#") ? 1 : c.depth - s.depth;
  });
}
function z(r, e, t) {
  for (var n = mr.bind(null, r, e), a = []; t > 0; ) {
    t -= 1;
    try {
      return n(a);
    } catch (i) {
      if (t > 0)
        return n(a);
      throw i;
    }
  }
}
function pr(r, e, t, n) {
  var a = K(r, t), i = a.split(/(?=[#:/*.]\w)/g).length, c = Object.assign({}, n, { fullpath: a, depth: i });
  if (!r || !"#/".includes(r.charAt()))
    throw new TypeError("Routes should have a valid path, given " + JSON.stringify(r));
  if (!c.key)
    throw new TypeError("Routes should have a key, given " + JSON.stringify(c));
  e.refs[c.key] = c, e.refs[a] = e.refs[a] ? e.refs[a].concat(c.key) : [c.key];
  var s = e;
  return b(a, function(f, d) {
    s = m.push(f, s, d, a);
  }), a;
}
function Fr(r, e, t) {
  var n = K(r, t), a = e, i = null, c = null;
  if (b(n, function(f) {
    if (!a)
      return i = null, true;
    if (!a.keys)
      throw new w(r, f);
    c = f, i = a, a = a[c];
  }), !(i && c))
    throw new w(r, c);
  if (i === e && (i = e["/"]), i.route !== c) {
    var s = i.keys.indexOf(c);
    if (s === -1)
      throw new w(r, c);
    i.keys.splice(s, 1), m.sort(i), delete i[c];
  }
  i.route === a.route && delete e.refs[n];
}
var W = function() {
  var e = { refs: {} }, t = [];
  return { routes: e, resolve: function(n, a) {
    var i = n.split("?")[0], c = [];
    b(i, function(s, f, d) {
      try {
        a(null, z(f, e, 2).filter(function(u) {
          return c.includes(u.route) ? false : (c.push(u.route), true);
        }), f);
      } catch (u) {
        a(u, []);
      }
    });
  }, mount: function(n, a) {
    n !== "/" && t.push(n), a(), t.pop();
  }, find: function(n, a) {
    return z(n, e, a === true ? 2 : a || 1);
  }, add: function(n, a) {
    return pr(n, e, t.join(""), a);
  }, rm: function(n) {
    return Fr(n, e, t.join(""));
  } };
};
W.matches = function(e, t) {
  return G(e, t).regex.test(t);
};
var wr = W;
var export_parse = X.parse;
var export_stringify = X.stringify;

// node_modules/yrv/build/dist/lib/utils.js
var cache = {};
var baseTag = document.getElementsByTagName("base");
var basePrefix = baseTag[0] && baseTag[0].href || "/";
var ROOT_URL = basePrefix.replace(window.location.origin, "");
var router = writable({
  path: "/",
  query: {},
  params: {},
  initial: true
});
var CTX_ROUTER = {};
var CTX_ROUTE = {};
var HASHCHANGE = window.location.origin === "null";
function hashchangeEnable(value) {
  if (typeof value === "boolean") {
    HASHCHANGE = !!value;
  }
  return HASHCHANGE;
}
Object.defineProperty(router, "hashchange", {
  set: (value) => hashchangeEnable(value),
  get: () => hashchangeEnable(),
  configurable: false,
  enumerable: false
});
function fixedLocation(path, callback, doFinally) {
  const baseUri = router.hashchange ? window.location.hash.replace("#", "") : window.location.pathname;
  if (path.charAt() !== "/") {
    path = baseUri + path;
  }
  const currentURL2 = baseUri + window.location.hash + window.location.search;
  if (currentURL2 !== path) {
    callback(path);
  }
  if (typeof doFinally === "function") {
    doFinally();
  }
}
function cleanPath(uri, fix) {
  return uri !== "/" || fix ? uri.replace(/\/$/, "") : uri;
}
function navigateTo(path, options) {
  const {
    reload,
    replace,
    params,
    queryParams
  } = options || {};
  if (!path || typeof path !== "string" || path[0] !== "/" && path[0] !== "#") {
    throw new Error(`Expecting '/${path}' or '#${path}', given '${path}'`);
  }
  if (params) {
    path = path.replace(/:([a-zA-Z][a-zA-Z0-9_-]*)/g, (_, key) => params[key]);
  }
  if (queryParams) {
    const qs = export_stringify(queryParams);
    if (qs) {
      path += `?${qs}`;
    }
  }
  if (router.hashchange) {
    let fixedURL = path.replace(/^#|#$/g, "");
    if (ROOT_URL !== "/") {
      fixedURL = fixedURL.replace(cleanPath(ROOT_URL), "");
    }
    window.location.hash = fixedURL !== "/" ? fixedURL : "";
    return;
  }
  if (reload || !window.history.pushState || !window.dispatchEvent) {
    window.location.href = path;
    return;
  }
  fixedLocation(path, (nextURL) => {
    window.history[replace ? "replaceState" : "pushState"](null, "", nextURL);
    window.dispatchEvent(new Event("popstate"));
  });
}
function getProps(given, required) {
  const { props: sub, ...others } = given;
  required.forEach((k2) => {
    delete others[k2];
  });
  return {
    ...sub,
    ...others
  };
}
function isActive(uri, path, exact) {
  if (!cache[[uri, path, exact]]) {
    if (exact !== true && path.indexOf(uri) === 0) {
      cache[[uri, path, exact]] = /^[#/?]?$/.test(path.substr(uri.length, 1));
    } else if (uri.includes("*") || uri.includes(":")) {
      cache[[uri, path, exact]] = wr.matches(uri, path);
    } else {
      cache[[uri, path, exact]] = cleanPath(path) === uri;
    }
  }
  return cache[[uri, path, exact]];
}
function isPromise(object) {
  return object && typeof object.then === "function";
}
function isSvelteComponent(object) {
  return object && object.prototype;
}

// node_modules/yrv/build/dist/lib/router.js
var baseRouter = new wr();
var routeInfo = writable({});
var onError = {};
var shared = {};
var errors = [];
var routers = 0;
var interval;
var currentURL;
router.subscribe((value) => {
  shared.router = value;
});
routeInfo.subscribe((value) => {
  shared.routeInfo = value;
});
function doFallback(failure, fallback) {
  routeInfo.update((defaults) => ({
    ...defaults,
    [fallback]: {
      ...shared.router,
      failure
    }
  }));
}
function handleRoutes(map, params, enforce) {
  map.some((x) => {
    if (x.key && (enforce || x.matches && !shared.routeInfo[x.key])) {
      if (x.redirect && (x.condition === null || x.condition(shared.router) !== true)) {
        if (x.exact && shared.router.path !== x.path)
          return false;
        navigateTo(x.redirect);
        return true;
      }
      if (x.exact && x.path !== currentURL) {
        if (currentURL.replace(/[#/]$/, "") !== x.path)
          return false;
      }
      if (enforce && x.fallback) {
        return false;
      }
      Object.assign(params, x.params);
      routeInfo.update((defaults) => ({
        ...defaults,
        [x.key]: {
          ...shared.router,
          ...x
        }
      }));
    }
    return false;
  });
}
function evtHandler() {
  let baseUri = !router.hashchange ? window.location.href.replace(window.location.origin, "") : window.location.hash || "/";
  let failure;
  if (ROOT_URL !== "/") {
    baseUri = baseUri.replace(cleanPath(ROOT_URL), "");
  }
  if (/^#[\w-]+$/.test(window.location.hash) && document.querySelector(window.location.hash) && currentURL === baseUri.split("#")[0])
    return;
  const normalizedURL = baseUri.replace("/#", "#").replace(/^#\//, "/");
  const [path, qs] = normalizedURL.split("?");
  const fullpath = path.replace(/\/?$/, "/");
  const params = {};
  if (currentURL !== normalizedURL) {
    currentURL = normalizedURL;
    router.set({
      path: cleanPath(fullpath),
      query: export_parse(qs),
      params
    });
  }
  routeInfo.set({});
  baseRouter.resolve(fullpath, (err, result) => {
    if (err) {
      failure = err;
      return;
    }
    handleRoutes(result, params);
  });
  if (!failure) {
    try {
      handleRoutes(baseRouter.find(fullpath), params, true);
    } catch (e) {
    }
  }
  if (failure && failure.path !== "/") {
    console.debug(failure);
  } else {
    failure = null;
  }
  errors.forEach((cb) => cb());
  errors = [];
  let fallback;
  Object.keys(onError).forEach((root) => {
    if (isActive(root, fullpath, false)) {
      const fn = onError[root].callback;
      fn(failure);
      errors.push(fn);
    }
    if (!fallback && onError[root].fallback) {
      fallback = onError[root].fallback;
    }
  });
  if (failure && fallback) {
    doFallback(failure, fallback);
  }
}
function findRoutes() {
  clearTimeout(interval);
  interval = setTimeout(evtHandler);
}
function addRouter(root, fallback, callback) {
  if (!routers) {
    window.addEventListener("popstate", findRoutes, false);
  }
  if (!onError[root] || fallback) {
    onError[root] = { fallback, callback };
  }
  routers += 1;
  return () => {
    routers -= 1;
    if (!routers) {
      window.removeEventListener("popstate", findRoutes, false);
    }
  };
}

// node_modules/yrv/build/dist/lib/Router.svelte
var get_default_slot_changes = (dirty) => ({ router: dirty & /*$router*/
2 });
var get_default_slot_context = (ctx) => ({ router: (
  /*$router*/
  ctx[1]
) });
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $router*/
        130)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(105:0) {#if !disabled}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*disabled*/
  ctx[0] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!/*disabled*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*disabled*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function unassignRoute(route) {
  try {
    baseRouter.rm(route);
  } catch (e) {
  }
  findRoutes();
}
function instance($$self, $$props, $$invalidate) {
  let $router;
  let $basePath;
  validate_store(router, "router");
  component_subscribe($$self, router, ($$value) => $$invalidate(1, $router = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router", slots, ["default"]);
  let cleanup;
  let failure;
  let fallback;
  let { key = "" } = $$props;
  let { path = "/" } = $$props;
  let { pending = null } = $$props;
  let { disabled = false } = $$props;
  let { condition = null } = $$props;
  const routerContext = getContext(CTX_ROUTER);
  const basePath = routerContext ? routerContext.basePath : writable(path);
  validate_store(basePath, "basePath");
  component_subscribe($$self, basePath, (value) => $$invalidate(12, $basePath = value));
  const fixedRoot = $basePath !== path && $basePath !== "/" ? `${$basePath}${path !== "/" ? path : ""}` : path;
  function assignRoute(_key, route, detail) {
    _key = _key || `route-${Math.random().toString(36).substr(2)}`;
    const $key = [key, _key].filter(Boolean).join(".");
    const handler = { key: $key, ...detail };
    let fullpath;
    baseRouter.mount(fixedRoot, () => {
      fullpath = baseRouter.add(route, handler);
      fallback = handler.fallback && $key || fallback;
    });
    findRoutes();
    return [$key, fullpath];
  }
  function onError2(err) {
    failure = err;
    if (failure && fallback) {
      doFallback(failure, fallback);
    }
  }
  onMount(() => {
    cleanup = addRouter(fixedRoot, fallback, onError2);
  });
  onDestroy(() => {
    if (cleanup)
      cleanup();
  });
  setContext(CTX_ROUTER, {
    basePath,
    assignRoute,
    unassignRoute,
    pendingComponent: pending
  });
  const writable_props = ["key", "path", "pending", "disabled", "condition"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Router> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(3, key = $$props2.key);
    if ("path" in $$props2)
      $$invalidate(4, path = $$props2.path);
    if ("pending" in $$props2)
      $$invalidate(5, pending = $$props2.pending);
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
    if ("condition" in $$props2)
      $$invalidate(6, condition = $$props2.condition);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    writable,
    CTX_ROUTER,
    router,
    baseRouter,
    addRouter,
    findRoutes,
    doFallback,
    onMount,
    onDestroy,
    getContext,
    setContext,
    cleanup,
    failure,
    fallback,
    key,
    path,
    pending,
    disabled,
    condition,
    routerContext,
    basePath,
    fixedRoot,
    assignRoute,
    unassignRoute,
    onError: onError2,
    $router,
    $basePath
  });
  $$self.$inject_state = ($$props2) => {
    if ("cleanup" in $$props2)
      cleanup = $$props2.cleanup;
    if ("failure" in $$props2)
      failure = $$props2.failure;
    if ("fallback" in $$props2)
      fallback = $$props2.fallback;
    if ("key" in $$props2)
      $$invalidate(3, key = $$props2.key);
    if ("path" in $$props2)
      $$invalidate(4, path = $$props2.path);
    if ("pending" in $$props2)
      $$invalidate(5, pending = $$props2.pending);
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
    if ("condition" in $$props2)
      $$invalidate(6, condition = $$props2.condition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*condition, $router*/
    66) {
      $:
        if (condition) {
          $$invalidate(0, disabled = !condition($router));
        }
    }
  };
  return [disabled, $router, basePath, key, path, pending, condition, $$scope, slots];
}
var Router = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      key: 3,
      path: 4,
      pending: 5,
      disabled: 0,
      condition: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router",
      options,
      id: create_fragment.name
    });
  }
  get key() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get path() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pending() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pending(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get condition() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set condition(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Router_default = Router;

// node_modules/yrv/build/dist/lib/Route.svelte
var get_default_slot_spread_changes = (dirty) => dirty & /*activeProps*/
8;
var get_default_slot_changes2 = (dirty) => ({});
var get_default_slot_context2 = (ctx) => ({ .../*activeProps*/
ctx[3] });
function create_if_block2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_if_block_5, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*hasLoaded*/
    ctx2[4])
      return 0;
    if (
      /*component*/
      ctx2[0]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(133:0) {#if activeRouter}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, activeProps*/
        65544)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            get_default_slot_spread_changes(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(148:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*activeProps*/
    ctx[3]
  ];
  var switch_value = (
    /*component*/
    ctx[0]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*activeProps*/
    8) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*activeProps*/
        ctx2[3]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*component*/
      1 && switch_value !== (switch_value = /*component*/
      ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*activeProps*/
        8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*activeProps*/
          ctx2[3]
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(146:4) {#if component}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*pending*/
    (ctx[1] || /*pendingComponent*/
    ctx[5]) && create_if_block_2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*pending*/
        ctx2[1] || /*pendingComponent*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*pending*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(135:2) {#if !hasLoaded}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3, create_if_block_4, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & /*pending*/
    2)
      show_if = null;
    if (show_if == null)
      show_if = !!isSvelteComponent(
        /*pending*/
        ctx2[1]
      );
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!isSvelteComponent(
        /*pendingComponent*/
        ctx2[5]
      );
    if (show_if_1)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(136:4) {#if pending || pendingComponent}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let t_value = (
    /*pending*/
    (ctx[1] || /*pendingComponent*/
    ctx[5]) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*pending*/
      2 && t_value !== (t_value = /*pending*/
      (ctx2[1] || /*pendingComponent*/
      ctx2[5]) + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(141:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*activeProps*/
    ctx[3]
  ];
  var switch_value = (
    /*pendingComponent*/
    ctx[5]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*activeProps*/
    8) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*activeProps*/
        ctx2[3]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = /*pendingComponent*/
      ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*activeProps*/
        8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*activeProps*/
          ctx2[3]
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(139:52) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*activeProps*/
    ctx[3]
  ];
  var switch_value = (
    /*pending*/
    ctx[1]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*activeProps*/
    8) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*activeProps*/
        ctx2[3]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*pending*/
      2 && switch_value !== (switch_value = /*pending*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*activeProps*/
        8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*activeProps*/
          ctx2[3]
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(137:6) {#if isSvelteComponent(pending)}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*activeRouter*/
    ctx[2] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*activeRouter*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*activeRouter*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $router;
  let $routeInfo;
  let $routePath;
  validate_store(router, "router");
  component_subscribe($$self, router, ($$value) => $$invalidate(14, $router = $$value));
  validate_store(routeInfo, "routeInfo");
  component_subscribe($$self, routeInfo, ($$value) => $$invalidate(15, $routeInfo = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Route", slots, ["default"]);
  let { key = null } = $$props;
  let { path = "/" } = $$props;
  let { exact = null } = $$props;
  let { pending = null } = $$props;
  let { disabled = false } = $$props;
  let { fallback = null } = $$props;
  let { component = null } = $$props;
  let { condition = null } = $$props;
  let { redirect = null } = $$props;
  const thisProps = [
    "key",
    "path",
    "exact",
    "pending",
    "disabled",
    "fallback",
    "component",
    "condition",
    "redirect"
  ];
  const routeContext = getContext(CTX_ROUTE);
  const routerContext = getContext(CTX_ROUTER);
  const { assignRoute, unassignRoute: unassignRoute2, pendingComponent } = routerContext || {};
  const routePath = routeContext ? routeContext.routePath : writable(path);
  validate_store(routePath, "routePath");
  component_subscribe($$self, routePath, (value) => $$invalidate(19, $routePath = value));
  let activeRouter = null;
  let activeProps = {};
  let fullpath;
  let hasLoaded;
  const fixedRoot = $routePath !== path && $routePath !== "/" ? `${$routePath}${path !== "/" ? path : ""}` : path;
  function resolve() {
    const fixedRoute = path !== fixedRoot && fixedRoot.substr(-1) !== "/" ? `${fixedRoot}/` : fixedRoot;
    $$invalidate(7, [key, fullpath] = assignRoute(key, fixedRoute, { condition, redirect, fallback, exact }), key);
  }
  resolve();
  onDestroy(() => {
    if (unassignRoute2) {
      unassignRoute2(fullpath);
    }
  });
  setContext(CTX_ROUTE, { routePath });
  $$self.$$set = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("key" in $$new_props)
      $$invalidate(7, key = $$new_props.key);
    if ("path" in $$new_props)
      $$invalidate(8, path = $$new_props.path);
    if ("exact" in $$new_props)
      $$invalidate(9, exact = $$new_props.exact);
    if ("pending" in $$new_props)
      $$invalidate(1, pending = $$new_props.pending);
    if ("disabled" in $$new_props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("fallback" in $$new_props)
      $$invalidate(11, fallback = $$new_props.fallback);
    if ("component" in $$new_props)
      $$invalidate(0, component = $$new_props.component);
    if ("condition" in $$new_props)
      $$invalidate(12, condition = $$new_props.condition);
    if ("redirect" in $$new_props)
      $$invalidate(13, redirect = $$new_props.redirect);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    writable,
    routeInfo,
    CTX_ROUTER,
    CTX_ROUTE,
    router,
    getProps,
    isPromise,
    isSvelteComponent,
    onDestroy,
    getContext,
    setContext,
    key,
    path,
    exact,
    pending,
    disabled,
    fallback,
    component,
    condition,
    redirect,
    thisProps,
    routeContext,
    routerContext,
    assignRoute,
    unassignRoute: unassignRoute2,
    pendingComponent,
    routePath,
    activeRouter,
    activeProps,
    fullpath,
    hasLoaded,
    fixedRoot,
    resolve,
    $router,
    $routeInfo,
    $routePath
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    if ("key" in $$props)
      $$invalidate(7, key = $$new_props.key);
    if ("path" in $$props)
      $$invalidate(8, path = $$new_props.path);
    if ("exact" in $$props)
      $$invalidate(9, exact = $$new_props.exact);
    if ("pending" in $$props)
      $$invalidate(1, pending = $$new_props.pending);
    if ("disabled" in $$props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("fallback" in $$props)
      $$invalidate(11, fallback = $$new_props.fallback);
    if ("component" in $$props)
      $$invalidate(0, component = $$new_props.component);
    if ("condition" in $$props)
      $$invalidate(12, condition = $$new_props.condition);
    if ("redirect" in $$props)
      $$invalidate(13, redirect = $$new_props.redirect);
    if ("activeRouter" in $$props)
      $$invalidate(2, activeRouter = $$new_props.activeRouter);
    if ("activeProps" in $$props)
      $$invalidate(3, activeProps = $$new_props.activeProps);
    if ("fullpath" in $$props)
      fullpath = $$new_props.fullpath;
    if ("hasLoaded" in $$props)
      $$invalidate(4, hasLoaded = $$new_props.hasLoaded);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      if (key) {
        $$invalidate(2, activeRouter = !disabled && $routeInfo[key]);
        $$invalidate(3, activeProps = getProps($$props, thisProps));
        $$invalidate(3, activeProps.router = activeRouter, activeProps);
      }
    if ($$self.$$.dirty & /*activeRouter, $router, component*/
    16389) {
      $:
        if (activeRouter) {
          for (const k2 in $router.params) {
            if (typeof activeRouter.params[k2] === "undefined") {
              $$invalidate(2, activeRouter.params[k2] = $router.params[k2], activeRouter);
            }
          }
          if (!component) {
            $$invalidate(4, hasLoaded = true);
          } else if (isSvelteComponent(component)) {
            $$invalidate(4, hasLoaded = true);
          } else if (isPromise(component)) {
            component.then((module) => {
              $$invalidate(0, component = module.default);
              $$invalidate(4, hasLoaded = true);
            });
          } else {
            component().then((module) => {
              $$invalidate(0, component = module.default);
              $$invalidate(4, hasLoaded = true);
            });
          }
        }
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    component,
    pending,
    activeRouter,
    activeProps,
    hasLoaded,
    pendingComponent,
    routePath,
    key,
    path,
    exact,
    disabled,
    fallback,
    condition,
    redirect,
    $router,
    $routeInfo,
    $$scope,
    slots
  ];
}
var Route = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      key: 7,
      path: 8,
      exact: 9,
      pending: 1,
      disabled: 10,
      fallback: 11,
      component: 0,
      condition: 12,
      redirect: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Route",
      options,
      id: create_fragment2.name
    });
  }
  get key() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get path() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get exact() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set exact(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pending() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pending(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallback() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallback(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get condition() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set condition(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirect() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirect(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Route_default = Route;

// node_modules/yrv/build/dist/lib/Link.svelte
var file = "node_modules\\yrv\\build\\dist\\lib\\Link.svelte";
function create_else_block2(ctx) {
  let a;
  let a_href_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let a_levels = [
    /*fixedProps*/
    ctx[6],
    {
      href: a_href_value = cleanPath(
        /*fixedHref*/
        ctx[5] || /*href*/
        ctx[1]
      )
    },
    { class: (
      /*cssClass*/
      ctx[0]
    ) },
    { title: (
      /*title*/
      ctx[2]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true, title: true });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file, 108, 2, 2944);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      ctx[19](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*handleAnchorOnClick*/
          ctx[8],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*fixedProps*/
        64 && /*fixedProps*/
        ctx2[6],
        (!current || dirty & /*fixedHref, href*/
        34 && a_href_value !== (a_href_value = cleanPath(
          /*fixedHref*/
          ctx2[5] || /*href*/
          ctx2[1]
        ))) && { href: a_href_value },
        (!current || dirty & /*cssClass*/
        1) && { class: (
          /*cssClass*/
          ctx2[0]
        ) },
        (!current || dirty & /*title*/
        4) && { title: (
          /*title*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[19](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(108:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let button_1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let button_1_levels = [
    /*fixedProps*/
    ctx[6],
    { class: (
      /*cssClass*/
      ctx[0]
    ) },
    { title: (
      /*title*/
      ctx[2]
    ) }
  ];
  let button_data = {};
  for (let i = 0; i < button_1_levels.length; i += 1) {
    button_data = assign(button_data, button_1_levels[i]);
  }
  const block = {
    c: function create() {
      button_1 = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", { class: true, title: true });
      var button_1_nodes = children(button_1);
      if (default_slot)
        default_slot.l(button_1_nodes);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button_1, button_data);
      add_location(button_1, file, 104, 2, 2818);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      if (default_slot) {
        default_slot.m(button_1, null);
      }
      if (button_1.autofocus)
        button_1.focus();
      ctx[18](button_1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          /*handleOnClick*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button_1, button_data = get_spread_update(button_1_levels, [
        dirty & /*fixedProps*/
        64 && /*fixedProps*/
        ctx2[6],
        (!current || dirty & /*cssClass*/
        1) && { class: (
          /*cssClass*/
          ctx2[0]
        ) },
        (!current || dirty & /*title*/
        4) && { title: (
          /*title*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[18](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(104:0) {#if button}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*button*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let fixedProps;
  let $router;
  validate_store(router, "router");
  component_subscribe($$self, router, ($$value) => $$invalidate(15, $router = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link", slots, ["default"]);
  let ref;
  let active;
  let { class: cssClass = "" } = $$props;
  let fixedHref = null;
  let { go = null } = $$props;
  let { open = null } = $$props;
  let { href = "" } = $$props;
  let { title = "" } = $$props;
  let { button = false } = $$props;
  let { exact = false } = $$props;
  let { reload = false } = $$props;
  let { replace = false } = $$props;
  const thisProps = ["go", "open", "href", "class", "title", "button", "exact", "reload", "replace"];
  const dispatch = createEventDispatcher();
  function handleOnClick(e) {
    e.preventDefault();
    if (typeof go === "string" && window.history.length > 1) {
      if (go === "back")
        window.history.back();
      else if (go === "fwd")
        window.history.forward();
      else
        window.history.go(parseInt(go, 10));
      return;
    }
    if (!fixedHref && href !== "") {
      if (open) {
        let specs = typeof open === "string" ? open : "";
        const wmatch = specs.match(/width=(\d+)/);
        const hmatch = specs.match(/height=(\d+)/);
        if (wmatch)
          specs += `,left=${(window.screen.width - wmatch[1]) / 2}`;
        if (hmatch)
          specs += `,top=${(window.screen.height - hmatch[1]) / 2}`;
        if (wmatch && !hmatch) {
          specs += `,height=${wmatch[1]},top=${(window.screen.height - wmatch[1]) / 2}`;
        }
        const w2 = window.open(href, "", specs);
        const t = setInterval(
          () => {
            if (w2.closed) {
              dispatch("close");
              clearInterval(t);
            }
          },
          120
        );
      } else
        window.location.href = href;
      return;
    }
    fixedLocation(
      href,
      () => {
        navigateTo(fixedHref || "/", { reload, replace });
      },
      () => dispatch("click", e)
    );
  }
  function handleAnchorOnClick(e) {
    if (e.metaKey || e.ctrlKey || e.button !== 0) {
      return;
    }
    handleOnClick(e);
  }
  function button_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(4, ref);
    });
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(4, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("class" in $$new_props)
      $$invalidate(0, cssClass = $$new_props.class);
    if ("go" in $$new_props)
      $$invalidate(9, go = $$new_props.go);
    if ("open" in $$new_props)
      $$invalidate(10, open = $$new_props.open);
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("title" in $$new_props)
      $$invalidate(2, title = $$new_props.title);
    if ("button" in $$new_props)
      $$invalidate(3, button = $$new_props.button);
    if ("exact" in $$new_props)
      $$invalidate(11, exact = $$new_props.exact);
    if ("reload" in $$new_props)
      $$invalidate(12, reload = $$new_props.reload);
    if ("replace" in $$new_props)
      $$invalidate(13, replace = $$new_props.replace);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    ROOT_URL,
    fixedLocation,
    navigateTo,
    cleanPath,
    isActive,
    getProps,
    router,
    ref,
    active,
    cssClass,
    fixedHref,
    go,
    open,
    href,
    title,
    button,
    exact,
    reload,
    replace,
    thisProps,
    dispatch,
    handleOnClick,
    handleAnchorOnClick,
    fixedProps,
    $router
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("ref" in $$props)
      $$invalidate(4, ref = $$new_props.ref);
    if ("active" in $$props)
      $$invalidate(14, active = $$new_props.active);
    if ("cssClass" in $$props)
      $$invalidate(0, cssClass = $$new_props.cssClass);
    if ("fixedHref" in $$props)
      $$invalidate(5, fixedHref = $$new_props.fixedHref);
    if ("go" in $$props)
      $$invalidate(9, go = $$new_props.go);
    if ("open" in $$props)
      $$invalidate(10, open = $$new_props.open);
    if ("href" in $$props)
      $$invalidate(1, href = $$new_props.href);
    if ("title" in $$props)
      $$invalidate(2, title = $$new_props.title);
    if ("button" in $$props)
      $$invalidate(3, button = $$new_props.button);
    if ("exact" in $$props)
      $$invalidate(11, exact = $$new_props.exact);
    if ("reload" in $$props)
      $$invalidate(12, reload = $$new_props.reload);
    if ("replace" in $$props)
      $$invalidate(13, replace = $$new_props.replace);
    if ("fixedProps" in $$props)
      $$invalidate(6, fixedProps = $$new_props.fixedProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*href*/
    2) {
      $:
        if (!/^(\w+:)?\/\//.test(href)) {
          $$invalidate(5, fixedHref = cleanPath(ROOT_URL, true) + cleanPath(router.hashchange ? `#${href}` : href));
        }
    }
    if ($$self.$$.dirty & /*ref, $router, href, exact, active, button*/
    51226) {
      $:
        if (ref && $router.path) {
          if (isActive(href, $router.path, exact)) {
            if (!active) {
              $$invalidate(14, active = true);
              ref.setAttribute("aria-current", "page");
              if (button) {
                ref.setAttribute("disabled", true);
              }
            }
          } else if (active) {
            $$invalidate(14, active = false);
            ref.removeAttribute("disabled");
            ref.removeAttribute("aria-current");
          }
        }
    }
    $:
      $$invalidate(6, fixedProps = getProps($$props, thisProps));
  };
  $$props = exclude_internal_props($$props);
  return [
    cssClass,
    href,
    title,
    button,
    ref,
    fixedHref,
    fixedProps,
    handleOnClick,
    handleAnchorOnClick,
    go,
    open,
    exact,
    reload,
    replace,
    active,
    $router,
    $$scope,
    slots,
    button_1_binding,
    a_binding
  ];
}
var Link = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      class: 0,
      go: 9,
      open: 10,
      href: 1,
      title: 2,
      button: 3,
      exact: 11,
      reload: 12,
      replace: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link",
      options,
      id: create_fragment3.name
    });
  }
  get class() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get go() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set go(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get button() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set button(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get exact() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set exact(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reload() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reload(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get replace() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set replace(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Link_default = Link;
export {
  Link_default as Link,
  Route_default as Route,
  Router_default as Router,
  navigateTo,
  router
};
//# sourceMappingURL=yrv.js.map
